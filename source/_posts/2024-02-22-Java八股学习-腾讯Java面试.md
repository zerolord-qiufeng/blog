---
title: Java八股学习-腾讯Java面试
layout: post
author: zerolord
tags: 
  - Java八股
  - 腾讯Java面试
  - 小林coding
categories: zerolord
keywords:
  - Java八股
  - 腾讯Java面试
  - 小林coding
date: 2024-02-22 09:52:12
---
## 408相关

### 操作系统

> 进程&线程
> 
> 典型开胃菜

本质区别：进程是操作系统资源分配的基本单位，线程是任务调度和执行的基本单位
开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大开销；线程可以看做轻量级的进程...切换开销小
稳定性：进程中的线程崩溃了，可能导致整个进程都崩溃，进程中的子进程崩溃，不会影响其他进程
内存分配：系统在运行的时候会为每个进程分配不同的内存空间，而不会为线程分配内存，线程组之间只能共享资源
包含关系：没有线程的进程可以看做单线程的，进程可以包含线程

> 为什么进程崩溃不会对其他进程造成很大影响
> 

进程隔离性：每个进程都有自己独立的空间，当一个进程崩溃时，其内存空间会被操作系统回收，不会影响其他进程的内存空间。
进程独立性：每个进程都是独立运行的，它们之间不会共享资源，如文件、网络连接等。


### 数据结构
> 知道哪些排序算法，时间复杂度是什么
> 
冒泡排序：通过相邻元素的比较和交换，每次将最大或最小的元素逐步冒泡到最后或最前

插入排序：将待排序元素逐个插入到已排序序列的合适位置，形成有序序列

## MySQL

> MySQL的存储引擎有哪些？为什么常用InnoDB？
> 
三个
InnoDB存储引擎：支持事务处理，支持外键，支持崩溃修复能力和并发控制。
 
> B+树和B树的比较
> 
B树和B+树都是通过多叉树的方式，会将树的高度减小，所以适合检索存储于磁盘中的数据

但是MySQL默认的存储引擎InnoDB采用的是B+作为索引的数据结构，原因：
* B+树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，B+树非叶子节点能存放更多索引，B+树高度更低，查询底层节点的磁盘I/O次数会更少
* B+树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让B+树在插入、删除的效率都更高
* B+树叶子结点之间用链表连接起来，有利于范围查询，而B树要实现范围查询，只能进行树的遍历，会涉及多个节点的磁盘I/O，效率很低

> 除了聚簇索引，还有什么索引
> 
还有二级索引、联合索引、前缀索引、唯一索引等

> 二级索引存放的有哪些数据

索引又可以分为聚簇索引和非聚簇索引（二级索引），它们的区别就在于叶子结点存放的是什么数据
* 聚簇索引的叶子结点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点
* 二级索引的叶子节点存放的是主键值，而不是实际数据

> 索引失效的情况
> 
* 当我们使用左或者左右模糊匹配的时候，也就是like %xx 或者 like %xx% 这两种方式都会造成索引失效
* 当我们在查询条件中对索引列使用函数，就会导致索引失效
* 当我们在查询条件中对索引列进行表达式计算
* MySQL在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过CAST函数实现的，等同于对索引列使用了函数，所以就会导致索引失效
* 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效

> 事务隔离级别有哪些

* 读未提交，指一个事务还没提交时，它做的变更就能被其他事务看到
* 读已提交，指一个事务提交之后，它做的变更才能被其他事务看到
* 可重复读，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的【InnoDB的默认隔离级别】
* 串行化，会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成

ps：中间这俩分不太清

> 什么情况下会出现脏读？

在一个事务内多次查询某个符合查询条件的“记录数量”，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了“幻读”

> 事务的MVCC是怎么实现的
> 
对于“读提交”和“可重复读”隔离级别的事务来说，它们是通过Read View来实现的，它们的区别在于创建Read View的时机不同：
* “读已提交”隔离级别是在每个select都会生成一个新的Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另一个事物修改了该记录，并提交了事务
* “可重复读”隔离级别是启动事务时生成一个Read View，然后整个事务期间都在用这个Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录

ps：
* 具体来说，Read View包含了当前事务开始时，已经提交的最老的事务ID和当前未提交事务ID的列表。
* 这两个隔离级别实现是通过“事务的Read View里的字段”和“记录中的两个隐藏列”的比对，来控制并发事务访问同一个记录时的行为，这就叫MVCC（多版本并发控制）
* 在创建Read View后，我们可以将记录中的trx_id划分为这三种情况：
![Read View](img.png)


## Redis

## Java

> 编译型语言和解释型语言的区别？
> 
> 常见开胃菜

编译型语言：在程序执行之前，整个源代码会被编译成机器码或字节码，生成可执行文件。执行时直接运行编译后的代码，速度快，但跨平台性差
解释型语言：在程序执行时，逐行解释执行源代码，不生成独立的可执行文件。通常由解释器动态解释并执行代码，跨平台性好，但执行速度相对较慢

> 动态数组的实现有哪些？
> 
ArrayList和Vector都支持动态扩容，都属于动态数组

> 比较这两者
* 线程安全性：Vector是线程安全的，ArrayList不是线程安全的
* 扩容策略：Vector在底层数组不够用时在原来的基础上扩展1倍，ArrayList是扩展0.5倍

线程安全是指在多线程环境下，对共享资源进行操作的代码，不会出现并发问题，不会破坏共享资源的正确性和一致性
 
> HashMap的扩容条件是什么

Java7是必须满足两个条件：
* 当前数据存储的数量（size()）大小大于等于阈值
* 当前加入的数据是否发生了hash冲突

Java8中扩容只需要满足一个条件：
* 当前存放新值的时候已有元素的个数大于等于阈值

## MQ
> 用的什么消息队列，消息队列怎么选型？

项目用的是RocketMQ消息队列，选择RocketMQ的原因是：
* 开发语言优势。RMQ采用Java语言开发，受众广，在遇到RMQ底层问题时，大部分熟悉Java的同学都可以深入阅读源码，分析排查问题
* 社区氛围活跃。RMQ是阿里巴巴开源的且内部使用较多，说明经得起生产环境考验
* 特性丰富。高级特性达到了12种，例如顺序消息、事务消息等

> 有没有消息积压的问题

导致消息积压突然增加，最粗粒度的原因，只有两种：发送变快了，消费变慢了

要解决积压的问题，可以通过扩容消费端的实例数来提升总体的消费能力

如果短时间内没有足够的服务器资源进行扩容，可以将系统降级，关闭一些不重要的业务，减少发送方发送的数据量

> RocketMQ消息可靠性如何保证
> 
使用一个消息队列其实就分为三大块：生产者、中间件、消费者，要保证消息就要保证三个环节都不能丢失数据

消息生产阶段：
* 生产者会不会丢消息，取决于生产者对于异常情况的处理是否合理。
* 从消息被生产出来，然后提交给MQ的过程中，只要能正常收到MQ的ack确认响应，就表示发送成功
* 所以只要处理好返回值和异常，如果异常则进行消息重发，那么这个阶段是不会出现消息丢失的

消息存储阶段：
* RabbitMQ或Kafka这类专业的消息队列中间件，在使用时是部署一个集群
* 生产者在发布消息时，队列中间件通常会写多个节点，也就是有多个副本，这样一来，即使一个节点挂了，也能保证集群的数据不丢失

消息消费阶段：
* 消费者接收消息+消息处理后，才回复ack的话，那么消息阶段的消息不会丢失
* 不能收到消息就回ack，否则可能消息处理中途挂掉了，消息就丢失了

> Kafka和RocketMQ消息确认机制有什么不同
> 
Kafka的消息确认机制有三种：0，1，-1


> Kafka和RocketMQ的broker架构有什么区别
> 

Kafka的broker架构：
* Kafka的broker架构采用了分布式的设计，每个Kafka broker是一个独立的服务实例，负责存储和处理一部分消息数据。
* Kafka的topic被分区存储在不同的broker上，实现了高水平扩展和高可用性

RMQ的：
* RMQ的是分布式的，但是每个RMQ broker有主从之分，一个主节点和多个从节点组成一个broker集群
* 主节点负责消息的写入和消费者的拉取，从节点负责消息的复制和消费者的负载均衡，提高了消息的可靠性和可用性

## 牛客网上的面经
Jvm：

jvm 内存区域？虚拟机栈中存储的数据？虚拟机栈会内存溢出吗？堆会内存溢出吗？（七七八八）
垃圾回收算法？（回答上来了）
分代分几代？什么时候对象存在新生代？什么时候存在老年代？（其实是想问GC的流程，什么时候对象存放到老年代答的不是很好）

Java集合：

简单说一下HasnMap？HashMap初始容量是多少？HashMap扩容机制说一下？如何实现自定义大小的HashMap？（扩容答的不行）

刚刚说到HashMap线程不安全，那什么是线程安全的 ？简单说一下currentHashMap？使用的是那种锁？（currentHashMap当时记不太清了，只回答了是用锁来实现线程安全的，使用一个继承于reentrantlock的锁，后面又看了一下，我回答的是jdk1.7版本之前的锁实现，jdk1.8就是使用的synchronized和CAS）

redis:

redis平时用来做什么？（缓存）
redis中的key存的是什么？如何保证数据库和缓存的一致性？
如果有大量的无效key，该怎么解决？（1，缓存无效key,设置较短的过期时间（ √ ）；2，可以使用布隆过滤器,没想起来）
提到了项目，简单问了一下用户登录使用到的MD5和加盐加密的过程？

计网：
TCP三次握手和四次挥手过程？TCP UDP的区别？以及他们的应用场景？为什么TCP是传输可靠的？（都答上了）


腾讯新闻1面
主要会根据你简历问
因为我是JAVA 部门是go和C++
所以大部分问的都是计网，数据库，git，IO模型之类的


Java：锁，JVM模型，垃圾回收，Redis跳表，索引失效（代码，贼考验基础）


arraylist和linkedlist
arraylist怎么扩容
虚拟机栈，怎么压栈
栈的大小是多少
栈会不会溢出，什么情况下会溢出
协程了解吗
问计网：time-wait状态，什么是MSL

3.讲一下JVM和每个区域存放什么？

4.垃圾回收是在哪个区域发生，讲一下垃圾回收？

5.说一下常见的数据结构？

6.红黑树的原理和特点？

7.Hash和红黑树的区别？

8.平衡二叉树和红黑树的区别？

9.介绍一下HashMap的底层数据结构

10.手撕：单链表的排序

当时嘴贱提了一句红黑树，一直围绕着这个问，底层不太懂，估计g了。










